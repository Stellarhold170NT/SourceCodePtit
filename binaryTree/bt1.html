<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Source code.ptit</title>
    <link rel="icon" type="image/x-icon" href="https://stellarhold170nt.github.io/SourceCodePtit/NeptuneLogo.png">
    <link rel="stylesheet" href="https://stellarhold170nt.github.io/SourceCodePtit/reset.css" />
    <link rel="stylesheet" href="https://stellarhold170nt.github.io/SourceCodePtit/assets/css/simple1.css"/>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;600&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-coy.min.css">
  </head>
<body>
    <a href="list.html"><div class="header">
    </div></a>
    <h1>/Binary Index Tree

    </h1>
    <p>&lt;Problem&gt;</p>
    <a href="#!" target="self">#!</a>
    <div class="code">
    <pre>
      <code class="language-cpp">        #include &lt;iostream&gt;
        using namespace std;
        
        template &lt;typename T&gt; class Node {
        public:
          Node&lt;T&gt;* left;
          Node&lt;T&gt;* right;
          T data;
        
          Node(T data) {
            this-&gt;data = data;
            this-&gt;left = nullptr;
            this-&gt;right = nullptr;
          }
        };
        
        template &lt;typename T&gt; class BinarySearchTree {
          Node&lt;T&gt;* root;
        public:
          BinarySearchTree() {
            root = nullptr;
          }
        
          void add(T value) {
            root = add(root, value);
          }
        
          Node&lt;T&gt;* add(Node&lt;T&gt;* r, T value) {
            if (r == nullptr) {
              return new Node&lt;T&gt;(value);
            }
            if (value &gt; r-&gt;data) {
              r-&gt;right = add(r-&gt;right, value);
            }
            else {
              r-&gt;left = add(r-&gt;left, value);
            }
            return r;
          }
        
          void inOrder() {
            inOrder(root);
          }
        
          void inOrder(Node&lt;T&gt;* r) {
            if (r != nullptr) {
              inOrder(r-&gt;left);
              cout &lt;&lt; r-&gt;data &lt;&lt; &quot; &quot;;
              inOrder(r-&gt;right);
            }
          }
        
          void preOrder() {
            preOrder(root);
          }
        
          void preOrder(Node&lt;T&gt;* r) {
            if (r != nullptr) {
              cout &lt;&lt; r-&gt;data &lt;&lt; &quot; &quot;;
              preOrder(r-&gt;left);
              preOrder(r-&gt;right);
            }
          }
        
          void postOrder() {
            postOrder(root);
          }
        
          void postOrder(Node&lt;T&gt;* r) {
            if (r != nullptr) {
              postOrder(r-&gt;left);
              postOrder(r-&gt;right);
              cout &lt;&lt; r-&gt;data &lt;&lt; &quot; &quot;;
            }
          }
        
          // tim kiem
          bool search(T key) {
            return search(root, key);
          }
        
          bool search(Node&lt;T&gt;* r, T key) {
            if (!r) {
              return false;
            }
            if (r-&gt;data == key) {
              return true;
            }
        
            if (r-&gt;data &lt; key) {
              return search(r-&gt;right, key);
            }
            else {
              return search(r-&gt;left, key);
            }
            return false;
          }
        
          int countNode() {
            return countNode(root);
          }
        
          int countNode(Node&lt;T&gt;* r) {
            if (r == nullptr) {
              return 0;
            }
            return 1 + countNode(r-&gt;left) + countNode(r-&gt;right);
          }
        
          int countLeafNode() {
            return countLeafNode(root);
          }
        
          int countLeafNode(Node&lt;T&gt;* r) {
            if (r == nullptr) {
              return 0;
            }
            if (r-&gt;left == nullptr &amp;&amp; r-&gt;right == nullptr) {
              return 1;
            }
            return countLeafNode(r-&gt;left) + countLeafNode(r-&gt;right);
          }
        
        };
        
        int main() {
          BinarySearchTree&lt;int&gt; tree;
          tree.add(80);
          tree.add(50);
          tree.add(100);
          tree.add(30);
          tree.add(40);
          tree.add(20);
          tree.add(90);
          tree.add(120);
          tree.add(95);
          tree.add(130);
          tree.add(110);
          tree.inOrder(); cout &lt;&lt; endl;
          cout &lt;&lt; &quot;So node tren cay: &quot; &lt;&lt; tree.countNode() &lt;&lt; endl;
          cout &lt;&lt; &quot;So node la tren cay: &quot; &lt;&lt; tree.countLeafNode() &lt;&lt; endl;
          // &lt;&lt; &quot;Ton tai node 30 tren cay? &quot; &lt;&lt; boolalpha &lt;&lt; tree.search(30) &lt;&lt; endl;
          //cout &lt;&lt; &quot;Ton tai node 10 tren cay? &quot; &lt;&lt; boolalpha &lt;&lt; tree.search(10) &lt;&lt; endl;
          // &lt;&lt; &quot;Ton tai node 110 tren cay? &quot; &lt;&lt; boolalpha &lt;&lt; tree.search(110) &lt;&lt; endl;
          return 0;
        }</code>
      </pre>
    </div>

      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

</body>
</html>